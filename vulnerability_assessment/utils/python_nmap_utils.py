import nmap
from concurrent.futures import ThreadPoolExecutor, as_completed
from active_recon.utils.python3_nmap_utils import convert_domain_or_ip
import os
import re
from django.conf import settings


def validate_port_range(port_range):
    # Define regex patterns for individual ports and port ranges
    individual_port_pattern = r"(\d{1,5})"
    port_range_pattern = r"(\d{1,5})-(\d{1,5})"

    # Split the input by commas to handle multiple ports/ranges
    parts = port_range.split(",")

    for part in parts:
        # Check if the part matches either an individual port or a port range
        if not re.match(f"^{individual_port_pattern}$", part) and not re.match(
            f"^{port_range_pattern}$", part
        ):
            return False
        if "-" in part:
            start, end = part.split("-")
            if int(start) > int(end) or int(start) < 1 or int(end) > 65535:
                return False
        else:
            port = int(part)
            if port < 1 or port > 65535:
                return False
    return True


def nmap_scan(ip_address, scan_args):
    """Function to perform a scan on a given IP address."""
    nm = nmap.PortScanner()
    nm.scan(ip_address, arguments=scan_args)
    return nm


def scan_vulnerabilities_concurrent(
    host_domain,
    port_range="1-1024",
    script_type="vulners",
    min_parallelism=10,
    max_parallelism=100,
):
    """Scan the given host for vulnerabilities using Nmap with concurrency."""
    print(f"Scanning {host_domain} for vulnerabilities")
    print(f"Port range is: {port_range}")

    # Convert domain to IP address if needed
    ip_address = convert_domain_or_ip(host_domain)
    if not ip_address:
        raise Exception("Issue with the domain or target IP that user input")

    # Define the arguments for the scan
    scan_args = f"-sV --script={script_type} -T5 -p {port_range} -Pn -n"  # T5 for faster execution

    # Add parallelism options if specified
    if min_parallelism:
        scan_args += f" --min-parallelism {min_parallelism}"
    if max_parallelism:
        scan_args += f" --max-parallelism {max_parallelism}"

    # Perform the scan concurrently
    with ThreadPoolExecutor(max_workers=20) as executor:
        futures = [executor.submit(nmap_scan, ip_address, scan_args)]
        results = []
        for future in as_completed(futures):
            nm = future.result()
            if ip_address in nm.all_hosts():
                for host in nm.all_hosts():
                    host_info = {
                        "host": host,
                        "hostname": nm[host].hostname(),
                        "state": nm[host].state(),
                        "protocols": [],
                    }
                    for proto in nm[host].all_protocols():
                        protocol_info = {"protocol": proto, "ports": []}
                        lport = nm[host][proto].keys()
                        for port in lport:
                            port_info = {
                                "port": port,
                                "state": nm[host][proto][port]["state"],
                                "scripts": nm[host][proto][port].get("script", {}),
                            }
                            protocol_info["ports"].append(port_info)
                        host_info["protocols"].append(protocol_info)
                    results.append(host_info)
    return results if results else None
